// #TODO_dontcommit: add copyright everywhere (to file template also)
#pragma once

// #TODO_dontcommit: why the filename?
// #TODO_dontcommit: unreal types should be in a separate plugin I think. Others could just be in a third-party project

// #TODO_dontcommit: dimensions must be blueprint editable

#include "Quantity.h"
#include "Unit.h"

#include <variant>

#include "TypedDouble.generated.h"

// #TODO_dontcommit should be in separate include file
UENUM()
enum class ESetSelectedUnitStrategy : uint8
{
	// Keep the numerical value the same while changing unit. E.g. for mass this will convert 3 grams to 3 kilograms
	KeepNumericalValue,
	// Keep the represented quantity the same. E.g. for mass this will convert 3 grams to 0.003 kilograms
	KeepQuantityValue,
};

{% for quantity in quantities %}

{% set cap_quantity = quantity.name|capitalize %}

UENUM()
enum class E{{ cap_quantity }}Unit : uint8
{
    {% for unit in quantity.units %}
    {{ unit.name|capitalize }} UMETA(DisplayName="{{ unit.suffix }}"),
    {% endfor %}
};

template <class {{ cap_quantity }}Unit>
struct F{{ cap_quantity }}UnitTraits;

{% for unit in quantity.units %}
template <>
struct F{{ cap_quantity }}UnitTraits<SafeMath::Units::F{{ unit.name|capitalize }}>
{
	constexpr static E{{ cap_quantity }}Unit {{ cap_quantity }}Unit = E{{ cap_quantity }}Unit::{{ unit.name|capitalize }};

	inline static const TCHAR* Suffix = TEXT("{{ unit.suffix }}");
};
{% endfor %}

using F{{ cap_quantity }}Unit = std::variant<
{% for unit in quantity.units %}
    SafeMath::Units::F{{ unit.name|capitalize }}{% if not loop.last %},{% endif %}
{% endfor %}
>;

constexpr F{{ cap_quantity }}Unit GetUnitVariant(const E{{ cap_quantity }}Unit {{ cap_quantity }}Unit)
{
	switch ({{ cap_quantity }}Unit)
	{
{% for unit in quantity.units %}
        case E{{ cap_quantity }}Unit::{{ unit.name|capitalize }}:
			return F{{ cap_quantity }}Unit{ SafeMath::Units::F{{ unit.name|capitalize }}{} };
{% endfor %}
        default:
            return F{{ cap_quantity }}Unit{ SafeMath::Units::F{{ quantity.default_unit_type|capitalize }}{} };
	}
}

USTRUCT()
struct F{{ cap_quantity }} 
{
	GENERATED_BODY()

	using DefaultUnitType = SafeMath::Units::F{{ quantity.default_unit_type|capitalize }};

    using NumericType = double;

	using QuantityType = SafeMath::TQuantity<DefaultUnitType, NumericType>;

	using UnitEnumType = E{{ cap_quantity }}Unit;

	static FName GetValuePropertyName()
	{
		return GET_MEMBER_NAME_CHECKED(F{{ cap_quantity }}, Value);
	}

	static FName GetSelectedUnitPropertyName()
	{
		return GET_MEMBER_NAME_CHECKED(F{{ cap_quantity }}, SelectedUnit);
	}

	F{{ cap_quantity }}() = default;

	template <class CompatibleUnitType>
	F{{ cap_quantity }}(SafeMath::TQuantity<CompatibleUnitType, NumericType> Quantity)
		: Value(Quantity.template GetValue<DefaultUnitType>())
#if WITH_EDITORONLY_DATA
		, SelectedUnit(F{{ cap_quantity }}UnitTraits<CompatibleUnitType>::{{ cap_quantity }}Unit)
#endif
	{
		static_assert(SafeMath::IsSameDimension(DefaultUnitType{}, CompatibleUnitType{}));
	}

	operator QuantityType() const
	{
		return GetQuantity();
	}

	QuantityType GetQuantity() const
	{
		return QuantityType{DefaultUnitType{}, Value};
	}

    template <class UnitType>
    NumericType GetValue() const
    {
        return GetQuantity().GetValue<UnitType>();
    }

#if WITH_EDITORONLY_DATA
	E{{ cap_quantity }}Unit GetSelectedUnit() const
	{
		return SelectedUnit;
	}

	void SetSelectedUnit(E{{ cap_quantity }}Unit InSelectedUnit, ESetSelectedUnitStrategy SetSelectedUnitStrategy)
	{
		if (SetSelectedUnitStrategy == ESetSelectedUnitStrategy::KeepNumericalValue)
		{
			const auto FromUnitVariant = GetUnitVariant(SelectedUnit);
			const auto ToUnitVariant = GetUnitVariant(InSelectedUnit);

			std::visit(
				[this](auto FromUnit, auto ToUnit)
				{ Value = SafeMath::GetConversionRateBetween(ToUnit, FromUnit) * Value; },
				FromUnitVariant,
				ToUnitVariant);
		}

		SelectedUnit = InSelectedUnit;
	}
#endif

	F{{ cap_quantity }}& operator*=(const NumericType Scalar)
	{
		Value *= Scalar;
		return *this;
	}

	F{{ cap_quantity }}& operator/=(const NumericType Scalar)
	{
		Value /= Scalar;
		return *this;
	}

private:
	// Always internally stored in default dimension unit (conversion rate == 1)
	UPROPERTY(EditAnywhere)
	double Value = 0.;

#if WITH_EDITORONLY_DATA
	UPROPERTY(EditAnywhere)
	E{{ cap_quantity }}Unit SelectedUnit = F{{ cap_quantity }}UnitTraits<DefaultUnitType>::{{ cap_quantity }}Unit;
#endif
};

inline F{{ cap_quantity }} operator*(const F{{ cap_quantity }} {{ cap_quantity }}, const double Scalar)
{
	return F{{ cap_quantity }}{ {{ cap_quantity }} } *= Scalar;
}

inline F{{ cap_quantity }} operator*(const double Scalar, const F{{ cap_quantity }} {{ cap_quantity }})
{
	return {{ cap_quantity }} * Scalar;
}

inline F{{ cap_quantity }} operator/(const F{{ cap_quantity }} {{ cap_quantity }}, const double Scalar)
{
	return F{{ cap_quantity }}{ {{ cap_quantity }} } /= Scalar;
}

inline F{{ cap_quantity }} operator/(const double Scalar, const F{{ cap_quantity }} {{ cap_quantity }})
{
	return {{ cap_quantity }} / Scalar;
}

{% endfor %}
